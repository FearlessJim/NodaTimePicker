@using NodaTime;

<div class="@ClassName" style="@MainStyle">
	@switch (ViewMode)
	{
		case TimeViewMode.Clock:
		{
			<div class="timepicker-clock">
				<button role="button" class="timepicker-hour-up timepicker-button" onclick=@IncrementHour>&uarr;</button>
				<button role="button" class="timepicker-hour timepicker-button" onclick=@DisplayHours>
					@HourDisplay
				</button>
				<button role="button" class="timepicker-hour-down timepicker-button" onclick=@DecrementHour>&darr;</button>

				<div class="timepicker-divider"><span>:</span></div>

				<button role="button" class="timepicker-minute-up timepicker-button" onclick=@IncrementMinute>&uarr;</button>
				<button role="button" class="timepicker-minute timepicker-button" onclick=@DisplayMinutes>
					@MinuteDisplay
				</button>
				<button role="button" class="timepicker-minute-down timepicker-button" onclick=@DecrementMinute>&darr;</button>

				@if (Is24Hour == false)
				{
					<button role="button" class="timepicker-meridiem timepicker-button" onclick=@ToggleMeridiem>
						@(State.IsAM ? "AM" : "PM")
					</button>
				}
			</div>
			}
			break;
		case TimeViewMode.Hours:
			{
				<div class="timepicker-hours">
					<div class="timepicker-hour-grid">
						@for (int i = 0; i < 12; i++)
						{
							var hour = ViewModeHours_IsAM ? i : i + 12;
							<button class="timepicker-button hour @(State.SelectedTime.Hour == hour ? "active" : "")" onclick=@(() => HourSelected(hour))>
								@($"{(Is24Hour ? hour : i):00}")
							</button>
						}
					</div>					
					<div class="timepicker-hour-meridiems">
						<button role="button" class="timepicker-button @(ViewModeHours_IsAM ? "active" : "")" onclick=@(() => ViewModeHours_IsAM = true)>AM</button>
						<button role="button" class="timepicker-button @(ViewModeHours_IsAM ? "" : "active")" onclick=@(() => ViewModeHours_IsAM = false)>PM</button>
					</div>
				</div>
			}
			break;
		case TimeViewMode.Minutes:
			{
				<div class="timepicker-minutes">
					<div class="timepicker-minute-grid">
						@for (int i = 0; i < 60; i += MinuteStep)
						{
							var minute = i;
							<button role="button" class="timepicker-button minute @(State.SelectedTime.Minute == minute ? "active" : "")" onclick=@(() => MinuteSelected(minute))>
								@($"{i:00}")
							</button>
						}
					</div>
				</div>
			}
			break;
	}
	@if (ShowClose)
	{
		<div class="timepicker-footer">
			<button class="timepicker-button-close" role="button" onclick=@close>
				Close
			</button>
		</div>		
	}
</div>

@functions {
		TimePickerState State = new TimePickerState();
	/// <summary>Any CSS classes to be applied to the wrapper element.</summary>
	[Parameter] protected string Class { get; set; }
	/// <summary>Any CSS styles to be applied to the wrapper element.</summary>
	[Parameter] protected string Style { get; set; }
	/// <summary>The maximum width of the wrapper element. Must be a valid CSS width value.</summary>
	[Parameter] protected string MaxWidth { get; set; }
	/// <summary>The width of the wrapper element. Must be a valid CSS width value.</summary>
	[Parameter] protected string Width { get; set; } = "250px;";
	/// <summary>Whether to use 24-hour time. Default is 12-hour time.</summary>
	[Parameter] protected bool Is24Hour { get; set; } = false;
	/// <summary>Whether to show the close button or not.</summary>
	[Parameter] protected bool ShowClose { get; set; }
	[Parameter] protected bool CloseOnSelect { get; set; }
	/// <summary>The number of minutes to increment or decrement by.</summary>
	[Parameter]
	protected int MinuteStep
	{
		get => State.MinuteStep;
		set => State.MinuteStep = value;
	}
	/// <summary>Whether the <see cref="TimePicker"/> should display Inline or not.</summary>
	[Parameter]
	protected bool Inline
	{
		get => State.Inline;
		set => State.Inline = value;
	}
	/// <summary>Whether the <see cref="TimePicker"/> should be visible or hidden.</summary>
	[Parameter]
	protected bool Visible
	{
		get => State.Visible;
		set => State.Visible = value;
	}

	/// <summary>Gets or sets the time displayed on the <see cref="TimePicker"/>.</summary>
	[Parameter] protected LocalTime SelectedTime
	{
		get => State.SelectedTime;
		set => State.SelectedTime = value;
	}

	[Parameter] protected Action<LocalTime> Changed { get; set; }

	void OnChanged()
	{
		Changed?.Invoke(State.SelectedTime);
		if (Inline == false && CloseOnSelect)
			close();

		StateHasChanged();
	}

	TimeViewMode ViewMode = TimeViewMode.Clock;

	string ClassName
	{
		get
		{
			if (!string.IsNullOrEmpty(Class))
				return $"{CssClassGenerator.TimePickerMain(Inline)} {Class}";
			else
				return CssClassGenerator.TimePickerMain(Inline);
		}
	}

	protected string MainStyle
	{
		get
		{
			var str = new List<string>()
			{
				"min-height:182px;"
			};

			if (Inline == false && Visible == false)
				str.Add("display:none;");
			if (!string.IsNullOrEmpty(Width))
				str.Add($"width:{Width};");
			if (!string.IsNullOrEmpty(MaxWidth))
				str.Add($"max-width:{MaxWidth};");

			str.Add(Style);

			return string.Join(" ", str);
		}
	}

	string HourDisplay
	{
		get
		{
			if (Is24Hour)
				return State.SelectedTime.ToString("HH", null);
			else
				return State.SelectedTime.ToString("hh", null);
		}
	}

	string MinuteDisplay => State.SelectedTime.ToString("mm", null);

	void DisplayClock()
	{
		ViewMode = TimeViewMode.Clock;
	}

	void DisplayHours()
	{
		ViewModeHours_IsAM = State.IsAM;
		ViewMode = TimeViewMode.Hours;
	}

	void DisplayMinutes()
	{
		ViewMode = TimeViewMode.Minutes;
	}

	void IncrementHour()
	{
		State.IncrementHour();
		OnChanged();
	}

	void DecrementHour()
	{
		State.DecrementHour();
		OnChanged();
	}

	void IncrementMinute()
	{
		State.IncrementMinute();
		OnChanged();
	}

	void DecrementMinute()
	{
		State.DecrementMinute();
		OnChanged();
	}

	void ToggleMeridiem()
	{
		State.ToggleMeridiem();
		OnChanged();
	}

	void HourSelected(int hour)
	{
		State.SetHour(hour);
		ViewMode = TimeViewMode.Clock;
		OnChanged();
	}

	void MinuteSelected(int minute)
	{
		State.SetMinute(minute);
		ViewMode = TimeViewMode.Clock;
		OnChanged();
	}

	bool ViewModeHours_IsAM { get; set; }

	void close()
	{
		if (Inline == false)
			Visible = false;		
	}
}