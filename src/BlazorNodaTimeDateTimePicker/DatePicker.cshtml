@using NodaTime
@using NodaTime.Extensions
<DayElement potato="hello"></DayElement>
<div class="@ClassName" style="@MainStyle">
	<div class="datepicker-content">
		@if (State.ViewMode == ViewMode.Days)
		{
			<div class="datepicker-days">
				<div class="datepicker-header">
					<div class="prev" onclick="@PreviousMonth">@PrevContent</div>
					<div class="month" onclick="@SelectMonth">@MonthText</div>
					<div class="next" onclick="@NextMonth">@NextContent</div>
				</div>
				@if (DisplayDaysOfWeek)
				{
					<div class="datepicker-days-of-week">
						@{
							var dow = FirstDayOfWeek;
							do
							{
								<div class="@CssClassGenerator.DayOfWeek(dow, DaysOfWeekDisabled)">@DayOfWeekAbbreviation(dow)</div>
								dow = dow.Next();
							} while (dow != FirstDayOfWeek);
						}
					</div>
				}
				<div class="days">
					@foreach (var date in Days)
					{
						<div class="day-wrapper">
							<div class="@CssClassGenerator.Day(date, State)" onclick="@(e => DayClicked(e, date))">
								@date.Day
							</div>
						</div>
					}
				</div>
				@if (ShowToday || ShowClear)
				{
					<div class="datepicker-footer">
						@if (ShowToday)
						{
							<button onclick=@TodayClicked>@TodayText</button>
						}
						@if (ShowClear)
						{
							<button onclick="@ClearClicked">@ClearText</button>
						}
						@if (ShowClose && !Inline)
						{
							<button onclick="@CloseClicked">@CloseText</button>
						}
					</div>
				}
			</div>
		}
		else if (State.ViewMode == ViewMode.Months)
		{
			<div class="datepicker-months">
				<div class="datepicker-header">
					<div class="prev" onclick=@PreviousYear>@PrevContent</div>
					<div class="year" onclick=@SelectYear>@YearText</div>
					<div class="next" onclick=@NextYear>@NextContent</div>
				</div>
				<div class="months">
					@for (int i = 1; i <= 12; i++)
					{
						var month = i;
						<div class="@CssClassGenerator.Month(month, disabledMonths[month - 1], State)" onclick="@(e => MonthClicked(e, month))">@MonthName(month)</div>
					}
				</div>
			</div>
		}
		else if (State.ViewMode == ViewMode.Years)
		{
			<div class="datepicker-years">
				<div class="datepicker-header">
					<div class="prev" onclick=@PreviousDecade>@PrevContent</div>
					<div class="decade" onclick=@SelectDecade>@DecadeText</div>
					<div class="next" onclick=@NextDecade>@NextContent</div>
				</div>
				<div class="years">
					@for (int year = yearStart - 1; year <= yearEnd + 1; year++)
					{
						var y = year;
						<div class="@CssClassGenerator.Year(year, disabledYears[year], State)" onclick=@(e => YearClicked(e, y))>
							@year
						</div>
					}
				</div>
			</div>
		}
		else if (State.ViewMode == ViewMode.Decades)
		{
			<div class="datepicker-decades">
				<div class="datepicker-header">
					<div class="prev" onclick=@PreviousCentury>@PrevContent</div>
					<div class="century">@CenturyText</div>
					<div class="next" onclick=@NextCentury>@NextContent</div>
				</div>
			</div>
			<div class="decades">
				@for (int decade = decadeStart - 10; decade <= decadeEnd + 10; decade += 10)
				{
					var d = decade;
					<div class="@CssClassGenerator.Decade(decade, disabledDecades[decade], State)" onclick=@(e => DecadeClicked(e, d))>
						@decade
					</div>
				}
			</div>
		}
	</div>
</div>

@functions {
	DatePickerState State { get; set; } = new DatePickerState();

	/// <summary>Any CSS classes to be applied to the wrapper element.</summary>
	[Parameter] protected string Class { get; set; }
	/// <summary>Any CSS styles to be applied to the wrapper element.</summary>
	[Parameter] protected string Style { get; set; }
	/// <summary>If true, detailed information will be logged to the Console.</summary>
	[Parameter] protected bool Logging { get; set; } = false;
	[Parameter] protected System.Globalization.CultureInfo FormatProvider { get; set; } = System.Globalization.CultureInfo.InvariantCulture;
	/// <summary>If true, a row will be displayed with the day-of-week names. If false, it will not.</summary>
	[Parameter] protected bool DisplayDaysOfWeek { get; set; } = true;
	/// <summary>In <see cref="ViewMode.Days"/>, the format of the month and year in the header. Defaults to MMMM yyyy, i.e. October 2018.</summary>
	[Parameter] protected string DayViewHeaderFormat { get; set; } = "MMMM yyyy";
	/// <summary>In <see cref="ViewMode.Months"/>, the format of the year in the header. Defaults to yyyy, i.e. 2018.</summary>
	[Parameter] protected string MonthViewHeaderFormat { get; set; } = "yyyy";
	/// <summary>The maximum width of the wrapper element. Must be a valid CSS width value.</summary>
	[Parameter] protected string MaxWidth { get; set; }
	/// <summary>The width of the wrapper element. Must be a valid CSS width value.</summary>
	[Parameter] protected string Width { get; set; } = "250px;";
	/// <summary>If true, the Today button will be displayed. If false, it will be hidden.</summary>
	[Parameter] protected bool ShowToday { get; set; } = true;
	/// <summary>If true, the Clear button will be displayed. If false, it will be hidden.</summary>
	[Parameter] protected bool ShowClear { get; set; } = true;
	/// <summary>If true and <see cref="Inline"/> is true, the Clear button will be displayed. If false, or <see cref="Inline"/> is false, it will be hidden.</summary>
	[Parameter] protected bool ShowClose { get; set; } = false;
	/// <summary>The text to display on the Today button.</summary>
	[Parameter] protected string TodayText { get; set; } = "Today";
	/// <summary>The text to display on the Clear button.</summary>
	[Parameter] protected string ClearText { get; set; } = "Clear";
	/// <summary>The text to display on the Close button.</summary>
	[Parameter] protected string CloseText { get; set; } = "Close";
	/// <summary>The <see cref="ViewMode"/> to display on initialization. Defaults to <see cref="ViewMode.Days"/>.</summary>
	[Parameter] protected ViewMode InitialViewMode { get; set; } = ViewMode.Days;
	/// <summary>The content to display in the Previous button. Defaults to the Less Than character (&lt;)</summary>
	[Parameter] protected RenderFragment PrevContent { get; set; }
	/// <summary>The content to display in the Previous button. Defaults to the Greater Than character (&gt;)</summary>
	[Parameter] protected RenderFragment NextContent { get; set; }

	/// <summary>Whether the DatePicker should be visible or hidden.</summary>
	[Parameter] protected bool Visible
	{
		get => State.Visible;
		set => State.Visible = value;
	}
	/// <summary>Whether the DatePicker should display Inline or not.</summary>
	[Parameter] protected bool Inline
	{
		get => State.Inline;
		set => State.Inline = value;
	}
	/// <summary>The day of the week to start from, when in <see cref="ViewMode.Days"/>.</summary>
	[Parameter] protected IsoDayOfWeek FirstDayOfWeek
	{
		get => State.FirstDayOfWeek;
		set => State.FirstDayOfWeek = value;
	}
	[Parameter] protected LocalDate? SelectedDate
	{
		get => State.SelectedDate;
		set => State.SelectedDate = value;
	}
	/// <summary>The earliest date that can be selected, inclusive. A value of null indicates that there is no minimum date.</summary>
	[Parameter] protected LocalDate? MinDate
	{
		get => State.MinDate;
		set => State.MinDate = value;
	}
	/// <summary>The latest date that can be selected, inclusive. A value of null indicates that there is no maximum date.</summary>
	[Parameter] protected LocalDate? MaxDate
	{
		get => State.MaxDate;
		set => State.MaxDate = value;
	}
	/// <summary>Specific dates that cannot be selected.</summary>
	[Parameter] protected IEnumerable<LocalDate> DisabledDates
	{
		get => State.DisabledDates;
		set => State.DisabledDates = value;
	}
	/// <summary>Specific dates that can be selected. Note this overrides any disabled state.</summary>
	[Parameter] protected IEnumerable<LocalDate> EnabledDates
	{
		get => State.EnabledDates;
		set => State.EnabledDates = value;
	}
	/// <summary>Days of the week that cannot be selected.</summary>
	[Parameter] protected IEnumerable<IsoDayOfWeek> DaysOfWeekDisabled
	{
		get => State.DaysOfWeekDisabled;
		set => State.DaysOfWeekDisabled = value;
	}
	/// <summary>Inclusive date intervals that cannot be selected.</summary>
	[Parameter] protected IEnumerable<(LocalDate start, LocalDate end)> DisabledDateIntervals
	{
		get => State.DisabledDateIntervals;
		set => State.DisabledDateIntervals = value;
	}

	/// <summary>An event that is invoked whenever the <see cref="SelectedDate"/> value is changed.</summary>
	[Parameter] protected Action<LocalDate?> Changed { get; set; }
	/// <summary>An event that is invoked when the a day is selected.</summary>
	[Parameter] protected Action<LocalDate> Selected { get; set; }
	/// <summary>An event that is invoked when the selected day is cleared.</summary>
	[Parameter] protected Action Cleared { get; set; }
	/// <summary>An event that is invoked when the UI is updated.</summary>
	[Parameter] protected Action Updated { get; set; }

	// Parameters not yet in use
	[Parameter] protected bool CloseOnSelect { get; set; } = true;

	// Events not yet in use
	[Parameter] protected Action Shown { get; set; }
	[Parameter] protected Action Hidden { get; set; }
	[Parameter] protected Action Disabled { get; set; }
	[Parameter] protected Action Enabled { get; set; }

	// Private properties and fields
	IEnumerable<LocalDate> Days { get; set; }

	protected override void OnInit()
	{
		State.WriteToLog = Logging;

		State.Log(nameof(OnInit));

		State.OnStateChanged += StateHasChanged;

		State.OnSelectedDateChanged += OnChanged;
		State.OnSelected += OnSelected;
		State.OnCleared += OnCleared;

		State.OnMonthToDisplayChanged += RenderDays;
		State.OnYearToDisplayChanged += RenderMonths;
		State.OnDecadeToDisplayChanged += RenderYears;
		State.OnCenturyToDisplayChanged += RenderDecades;
	}

	protected override void OnParametersSet()
	{
		State.Log(nameof(OnParametersSet));

		State.ViewMode = InitialViewMode;

		switch (State.ViewMode)
		{
			case ViewMode.Days:
				RenderDays();
				break;
			case ViewMode.Months:
				RenderMonths();
				break;
			case ViewMode.Years:
				RenderYears();
				break;
			case ViewMode.Decades:
				RenderDecades();
				break;
			default:
				break;
		}

		if (PrevContent == null)
		{
			PrevContent = builder => builder.AddContent(1, new MarkupString("&lt;"));
		}
		if (NextContent == null)
		{
			NextContent = builder => builder.AddContent(1, new MarkupString("&gt;"));
		}
	}

	void OnChanged(LocalDate? localDate)
	{
		State.Log(nameof(OnChanged));

		Changed?.Invoke(localDate);
	}

	void OnSelected(LocalDate localDate)
	{
		State.Log(nameof(OnSelected));

		Selected?.Invoke(localDate);
	}

	void OnCleared()
	{
		State.Log(nameof(OnCleared));

		Cleared?.Invoke();
	}

	#region Days

	void RenderDays()
	{
		State.Log(nameof(RenderDays));

		var startOfWeekOfMonth = State.MonthToDisplay.StartOfWeek(FirstDayOfWeek);

		var endOfMonth = State.MonthToDisplay.EndOfMonth();
		var endOfWeekOfMonth = endOfMonth.EndOfWeek(FirstDayOfWeek);

		Days = GetDaysBetween(startOfWeekOfMonth, endOfWeekOfMonth);
	}

	void DayClicked(UIMouseEventArgs eventArgs, LocalDate date)
	{
		State.Log(nameof(DayClicked));

		if (!State.IsDayDisabled(date))
			State.SetSelectedDate(date);
	}

	#endregion

	static IEnumerable<LocalDate> GetDaysBetween(LocalDate start, LocalDate end)
	{
		if (start > end)
			yield break;

		do
		{
			yield return start;
			start = start.PlusDays(1);
		} while (start <= end);
	}

	string ClassName
	{
		get
		{
			if (!string.IsNullOrEmpty(Class))
				return $"{CssClassGenerator.Main(Inline)} {Class}";
			else
				return CssClassGenerator.Main(Inline);
		}
	}

	protected string MainStyle
	{
		get
		{
			var str = new List<string>();

			if (Inline == false && Visible == false)
				str.Add("display:none;");
			if (!string.IsNullOrEmpty(Width))
				str.Add($"width:{Width};");
			if (!string.IsNullOrEmpty(MaxWidth))
				str.Add($"max-width:{MaxWidth};");

			str.Add(Style);

			return string.Join(" ", str);
		}
	}

	string DayOfWeekAbbreviation(IsoDayOfWeek isoDayOfWeek)
	{
		return FormatProvider.DateTimeFormat.GetShortestDayName(isoDayOfWeek.ToDayOfWeek());
	}

	string MonthText
	{
		get { return State.MonthToDisplay.ToString(DayViewHeaderFormat, FormatProvider); }
	}

	string MonthName(int month)
	{
		return FormatProvider.DateTimeFormat.GetAbbreviatedMonthName(month);
	}

	string YearText
	{
		get { return State.MonthToDisplay.ToString(MonthViewHeaderFormat, FormatProvider); }
	}

	string DecadeText => State.MonthToDisplay.GetDecadeString();

	string CenturyText => State.MonthToDisplay.GetCenturyString();

	#region Months

	bool[] disabledMonths;

	void RenderMonths()
	{
		State.Log(nameof(RenderMonths));

		disabledMonths = new bool[12];

		for (int i = 0; i < 12; i++)
		{
			disabledMonths[i] = State.IsMonthDisabled(i + 1, State.MonthToDisplay.Year);
		}
	}

	void MonthClicked(UIMouseEventArgs eventArgs, int month)
	{
		State.Log(nameof(MonthClicked));

		if (disabledMonths[month - 1] == false)
		{
			State.SetDisplayMonth(month);
			State.PreviousViewMode();
		}
	}

	void NextMonth(UIMouseEventArgs eventArgs)
	{
		State.Log(nameof(NextMonth));

		State.NextMonth();
		RenderDays();
		OnUpdated();
	}

	void PreviousMonth(UIMouseEventArgs eventArgs)
	{
		State.Log(nameof(PreviousMonth));

		State.PreviousMonth();
		RenderDays();
		OnUpdated();
	}

	void SelectMonth(UIMouseEventArgs eventArgs)
	{
		State.Log(nameof(SelectMonth));

		RenderMonths();
		State.NextViewMode();
	}

	#endregion

	#region Years

	int yearStart, yearEnd;
	Dictionary<int, bool> disabledYears;

	void RenderYears()
	{
		State.Log(nameof(RenderYears));

		(yearStart, yearEnd) = State.MonthToDisplay.GetDecade();

		disabledYears = new Dictionary<int, bool>();

		for (int i = yearStart - 1; i <= yearEnd + 1; i++)
		{
			disabledYears.Add(i, State.IsYearDisabled(i));
		}
	}

	void YearClicked(UIMouseEventArgs eventArgs, int year)
	{
		State.Log(nameof(YearClicked));

		if (disabledYears[year] == false)
		{
			State.SetDisplayYear(year);
			RenderMonths();
			State.PreviousViewMode();
		}
	}

	void NextYear(UIMouseEventArgs eventArgs)
	{
		State.Log(nameof(NextYear));

		State.NextYear();
		OnUpdated();
	}

	void PreviousYear(UIMouseEventArgs eventArgs)
	{
		State.Log(nameof(PreviousYear));

		State.PreviousYear();
		OnUpdated();
	}

	void SelectYear(UIMouseEventArgs eventArgs)
	{
		State.Log(nameof(SelectYear));

		RenderYears();
		State.NextViewMode();
	}

	#endregion

	#region Decades

	int decadeStart, decadeEnd;
	Dictionary<int, bool> disabledDecades;

	void RenderDecades()
	{
		State.Log(nameof(RenderDecades));

		(decadeStart, decadeEnd) = State.MonthToDisplay.GetCentury();

		disabledDecades = new Dictionary<int, bool>();

		for (int i = decadeStart - 10; i <= decadeEnd + 10; i += 10)
		{
			disabledDecades.Add(i, State.IsDecadeDisabled(i));
		}
	}

	void DecadeClicked(UIMouseEventArgs eventArgs, int decade)
	{
		State.Log(nameof(DecadeClicked));

		if (disabledDecades[decade] == false)
		{
			State.SetDisplayYear(decade);
			RenderYears();
			State.PreviousViewMode();
		}
	}

	void NextDecade(UIMouseEventArgs eventArgs)
	{
		State.Log(nameof(NextDecade));

		State.NextDecade();
		OnUpdated();
	}

	void PreviousDecade(UIMouseEventArgs eventArgs)
	{
		State.Log(nameof(PreviousDecade));

		State.PreviousDecade();
		OnUpdated();
	}

	void SelectDecade(UIMouseEventArgs eventArgs)
	{
		State.Log(nameof(SelectDecade));

		RenderDecades();
		State.NextViewMode();
	}

	#endregion

	#region Centuries

	void NextCentury(UIMouseEventArgs eventArgs)
	{
		State.Log(nameof(NextCentury));

		State.NextCentury();
		OnUpdated();
	}

	void PreviousCentury(UIMouseEventArgs eventArgs)
	{
		State.Log(nameof(PreviousCentury));

		State.PreviousCentury();
		OnUpdated();
	}

	#endregion

	void TodayClicked(UIMouseEventArgs eventArgs)
	{
		State.Log(nameof(TodayClicked));

		State.SetSelectedDateToday();
	}

	void ClearClicked(UIMouseEventArgs eventArgs)
	{
		State.Log(nameof(ClearClicked));

		State.ClearSelectedDate();
	}

	void CloseClicked(UIMouseEventArgs eventArgs)
	{
		State.Log(nameof(CloseClicked));

		if (!Inline)
			State.Close();
	}

	void OnUpdated()
	{
		State.Log(nameof(OnUpdated));

		Updated?.Invoke();
	}
}
